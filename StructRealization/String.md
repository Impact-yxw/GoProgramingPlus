## 字符串
### 从编码说起
- 一个字节由8个比特组成，当比特位全为0时代表数字0，全为1时代表数字255，一个字节可以表示256个数字，2个字节可以表示65536个数字。
- 而字符的表示方法与之不同，是通过将字符进行编号，比如将`A`编号为`65`，对应二进制的`01000001`是这个字符的编码，通过这种映射关系可以将字符以比特的形式存起来，而这种映射关系就是字符集。
- 常见的字符集有： ASCII GB18030 GBK Unicode等等
**字符集促成了字符与二进制的合作，但如何表示字符串呢？**
`hello世界`
|字符|编号|二进制|
|--|--|--|
|h|104|0110 1000|
|e|101|0110 0101|
|l|108|0110 1100|
|l|108|0110 1100|
|o|111|0110 0111|
|世|19990|01001110 00010110|
|界|30028|01110101 01001100|
如果不加处理直接存放就是`01101000|01100101|01101100|01101100|01100111|0100111000010110|0111010101001100`，可以发现如果将分隔符去掉我们完全不知道这些比特串将要表达什么意思。
#### 解决方案
- 定长编码
无论字符的二进制表示原本有多长，全部按字符集最长的编码来比如 `e`:`00000000 00000000 00000000 01100101`
但这样明显是在浪费内存
- 变长编码
小编号字符少占用字节，大编号字符多占用字节

|编号|编码模板|
|---------|----------|
|`[0,127]`|`0???????`|
|`[128,2047]`|`110????? 10??????`|
|`[2048,65536]`|`1110???? 10?????? 10??????`|

比如对于`世` 编号`19990` 二进制表示`01001110 00010110` 变长编码 1110 `0100` 10`111000` 10`010110`

**以上编码方式就是所谓的`UTF-8`编码，也就是GO语言默认的编码方式**

### string in golang
`var str string = "hello"`
在c中字符串变量存放着一块以`\0`结尾的连续内存的起始地址，在go中字符串变量不光存放这个地址，还存放着这块连续内存占用多少个字节
~~~ go
type stringStruct struct {
	str unsafe.Pointer
	len int
}
~~~
string的数据结构跟切片有些类似，只不过切片还有一个表示容量的成员，事实上string和切片准确来说是`[]byte`经常发生交换

**在go中字符串是不可修改的，go认为字符串内容是不会被修改的**
- `fmt.Printf("%c\n",s[2])`可以这样访问字符串中的元素 
- `s[2] = 'h'`是不被允许的
**go的编译器会把以`s := "hello世界"`这样定义的字符串分配到只读内存段，**
